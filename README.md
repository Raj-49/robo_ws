# Dexter Vision-Based Pick and Place Robotic Arm

A complete ROS2 Humble robotics system featuring **virtual hardware testing**, MoveIt motion planning, and a modular architecture designed for seamless transition from simulation to real hardware.

[![ROS2](https://img.shields.io/badge/ROS2-Humble-blue)](https://docs.ros.org/en/humble/)
[![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)

---

## ğŸ¯ Project Overview

This repository implements a 6-DOF robotic arm with a 2-finger gripper, designed for pick-and-place operations. The system features a **virtual hardware environment** that enables complete software development and testing without physical hardware or heavy simulation.

### Key Features

- âœ… **Virtual Hardware Testing** - Develop without physical motors or Gazebo
- âœ… **MoveIt Integration** - Advanced motion planning with OMPL, CHOMP, and Pilz
- âœ… **ros2_control Architecture** - Industry-standard hardware abstraction
- âœ… **Validated Controllers** - Tested trajectory execution at 100Hz
- âœ… **Production-Ready** - Software stack ready for real hardware integration

---

## ğŸ—ï¸ System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                         â”‚
â”‚              (MoveIt, Custom Scripts, Vision)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Controller Manager                         â”‚
â”‚         (JointTrajectoryController @ 100Hz)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              hardware_interface::SystemInterface             â”‚
â”‚                    (ABSTRACTION LAYER)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â†“                                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FakeRobotHardware   â”‚              â”‚ RealRobotHardware   â”‚
â”‚ (Virtual Testing)   â”‚              â”‚ (Actual Motors)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Critical Insight**: Everything above the `SystemInterface` is **identical** whether using virtual or real hardware. This guarantees that validated software will work with physical motors.

---

## ğŸ“¦ Packages

### 1. `pick_place_arm`

Core robot definition and Gazebo simulation.

**Key Files**:

- `urdf/arm.urdf.xacro` - Robot model (links, joints, inertia)
- `launch/unified_gz_moveit.launch.py` - Gazebo + MoveIt integration
- `config/ros2_control.yaml` - Controller configuration

### 2. `arm_moveit_config`

MoveIt configuration generated by MoveIt Setup Assistant.

**Key Files**:

- `config/pick_place_arm.srdf` - Semantic robot description
- `config/kinematics.yaml` - IK solver configuration
- `config/moveit_controllers.yaml` - MoveIt controller mappings

### 3. `pick_place_hardware` â­ NEW

Virtual hardware testing environment.

**Key Files**:

- `src/fake_robot_hardware.cpp` - Hardware interface plugin
- `launch/test_fake_hardware.launch.py` - Virtual hardware launcher
- `scripts/test_controller.py` - Controller validation
- `scripts/test_moveit_integration.py` - End-to-end testing

---

## ğŸš€ Quick Start

### Prerequisites

```bash
# ROS2 Humble
sudo apt install ros-humble-desktop-full

# MoveIt2
sudo apt install ros-humble-moveit

# ros2_control
sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers

# Gazebo Fortress (optional, for simulation)
sudo apt install ros-humble-ros-gz
```

### Build

```bash
cd ~/pick_place_hardware_implementation/Dexter-vision-based-pick-place-robotic-arm
source /opt/ros/humble/setup.bash
colcon build --symlink-install
source install/setup.bash
```

### Launch Virtual Hardware (Recommended)

```bash
# Terminal 1: Launch the system
ros2 launch pick_place_hardware test_fake_hardware.launch.py
```

This opens RViz with MoveIt and activates all controllers **without** Gazebo overhead.

### Launch Gazebo Simulation (Alternative)

```bash
ros2 launch pick_place_arm unified_gz_moveit.launch.py
```

---

## ğŸ§ª Testing

### Automated Tests

```bash
# Test 1: Controller Validation
python3 src/pick_place_hardware/scripts/test_controller.py

# Expected Output:
# âœ“ Joint state rate: 100 Hz
# âœ“ Trajectory execution: SUCCESSFUL
```

```bash
# Test 2: MoveIt Integration
python3 src/pick_place_hardware/scripts/test_moveit_integration.py

# Expected Output:
# âœ“ Move to home: PASS
# âœ“ Move to pick: PASS
# âœ“ Return to home: PASS
```

### Manual Testing in RViz

1. Launch virtual hardware (see above)
2. In RViz, use the **MotionPlanning** panel
3. Select a goal state (e.g., "zero", "pick_1")
4. Click **Plan** â†’ **Execute**
5. Watch the robot move smoothly!

---

## ğŸ”¬ How Virtual Hardware Works

### The Problem with Traditional Development

Developing robotics software typically requires:

- âŒ Expensive physical hardware
- âŒ Heavy simulation (Gazebo) with physics overhead
- âŒ Risk of damaging motors during testing
- âŒ Slow iteration cycles

### Our Solution: FakeRobotHardware

The `FakeRobotHardware` plugin simulates **realistic motor behavior** without physics simulation:

| Real Hardware Behavior        | FakeRobotHardware Simulation                         |
| ----------------------------- | ---------------------------------------------------- |
| Communication delay (USB/CAN) | Command buffer with 50ms delay                       |
| Motor inertia & PID control   | First-order lag: `pos += (target - pos) Ã— gain Ã— dt` |
| Encoder noise                 | Gaussian noise: `Â±0.001 rad`                         |
| Position feedback             | State interfaces with simulated values               |

### Why This Proves Real Hardware Readiness

When tests pass with `FakeRobotHardware`, it **guarantees**:

1. **Controllers are configured correctly** â†’ Will work with real motors
2. **MoveIt can plan valid trajectories** â†’ Will work with real kinematics
3. **Timing constraints are met** â†’ Will meet real-time requirements
4. **Joint limits are respected** â†’ Won't damage real hardware

**The entire control stack is production-ready.** Only the hardware driver needs implementation.

---

## ğŸ”„ Transition to Real Hardware

When you're ready to connect physical motors:

### Step 1: Implement RealRobotHardware

```cpp
class RealRobotHardware : public hardware_interface::SystemInterface {
    hardware_interface::return_type read(...) override {
        // Read from actual motors (Dynamixel, CAN, etc.)
        for (size_t i = 0; i < hw_positions_.size(); i++) {
            hw_positions_[i] = motor_driver_->read_position(motor_ids_[i]);
        }
        return hardware_interface::return_type::OK;
    }

    hardware_interface::return_type write(...) override {
        // Send commands to actual motors
        for (size_t i = 0; i < hw_commands_.size(); i++) {
            motor_driver_->send_position(motor_ids_[i], hw_commands_[i]);
        }
        return hardware_interface::return_type::OK;
    }
};
```

### Step 2: Update URDF

```xml
<!-- Change from: -->
<plugin>pick_place_hardware/FakeRobotHardware</plugin>

<!-- To: -->
<plugin>pick_place_hardware/RealRobotHardware</plugin>
```

### Step 3: Run the Same Tests

The **exact same test scripts** validate real hardware!

```bash
python3 src/pick_place_hardware/scripts/test_controller.py
python3 src/pick_place_hardware/scripts/test_moveit_integration.py
```

---

## ğŸ“Š Robot Specifications

### Arm

- **DOF**: 6 (j1-j6)
- **Joint Type**: Revolute
- **Joint Limits**: -3.14 to 3.14 rad
- **Max Velocity**: 5 rad/s
- **Max Effort**: 3.5 Nm

### Gripper

- **DOF**: 2 (j7l, j7r)
- **Joint Type**: Prismatic
- **Range**: 0 to 0.025 m
- **Max Velocity**: 0.1 m/s
- **Max Effort**: 10 N

### Control

- **Update Rate**: 100 Hz
- **Controller Type**: JointTrajectoryController
- **Planning**: OMPL (RRTConnect, RRT\*, PRM)

---

## ğŸ“ Understanding the Code

### Critical Files Explained

#### [fake_robot_hardware.cpp](src/pick_place_hardware/src/fake_robot_hardware.cpp)

The heart of virtual hardware testing. Key methods:

- `on_init()` - Reads parameters (noise, delay, gain)
- `read()` - Returns simulated joint states
- `write()` - Buffers commands and updates simulation
- `export_state_interfaces()` - Provides position/velocity feedback
- `export_command_interfaces()` - Accepts position commands

#### [test_fake_hardware.launch.py](src/pick_place_hardware/launch/test_fake_hardware.launch.py)

Launches the system with virtual hardware:

```python
# Key configuration
mappings={
    "use_fake_hardware": "true",
    "gazebo_control": "false"  # Disable Gazebo ros2_control
}
```

#### [arm.urdf.xacro](src/pick_place_arm/urdf/arm.urdf.xacro)

Robot model with conditional hardware:

```xml
<xacro:if value="$(arg gazebo_control)">
    <!-- Gazebo hardware interface -->
</xacro:if>
```

---

## ğŸ› ï¸ Customization

### Adjust Virtual Hardware Parameters

Edit [`fake_hardware.ros2_control.xacro`](src/pick_place_hardware/config/fake_hardware.ros2_control.xacro):

```xml
<param name="noise_level">0.001</param>      <!-- Encoder noise (rad) -->
<param name="actuator_delay">0.05</param>    <!-- Command delay (sec) -->
<param name="position_gain">5.0</param>      <!-- Response speed -->
```

### Add Custom Named Poses

Edit [`pick_place_arm.srdf`](src/arm_moveit_config/config/pick_place_arm.srdf):

```xml
<group_state name="my_pose" group="arm">
    <joint name="j1" value="0.0"/>
    <joint name="j2" value="1.57"/>
    <!-- ... -->
</group_state>
```

---

## ğŸ“š Additional Resources

### Documentation

- [Virtual Hardware Explained](docs/virtual_hardware_explained.md) - Deep dive into the abstraction layer
- [Hardware Integration Plan](docs/hardware_integration_plan.md) - Real hardware roadmap
- [Testing Guide](docs/testing_guide.md) - Comprehensive testing instructions

### ROS2 Resources

- [ros2_control Documentation](https://control.ros.org/humble/index.html)
- [MoveIt2 Tutorials](https://moveit.picknik.ai/humble/index.html)
- [Writing a Hardware Interface](https://control.ros.org/humble/doc/ros2_control/hardware_interface/doc/writing_new_hardware_interface.html)

---

## ğŸ¤ Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

---

## ğŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ™ Acknowledgments

- **ROS2 Community** - For the incredible robotics framework
- **MoveIt** - For motion planning capabilities
- **ros2_control** - For the hardware abstraction layer

---

## ğŸ“§ Contact

**Raj** - [@Raj-49](https://github.com/Raj-49)

**Project Link**: https://github.com/Raj-49/Dexter-vision-based-pick-place-robotic-arm

---

## ğŸ¯ Project Status

- âœ… **Virtual Hardware**: Complete and tested
- âœ… **MoveIt Integration**: Validated
- âœ… **Gazebo Simulation**: Working
- ğŸš§ **Real Hardware**: Ready for implementation
- ğŸš§ **Vision Integration**: Planned
- ğŸš§ **Autonomous Pick-Place**: Planned

**Current Branch**: `standalone-hardware-integration`  
**Status**: Production-ready software stack, awaiting physical hardware
